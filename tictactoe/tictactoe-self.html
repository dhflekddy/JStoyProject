<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>틱택토</title>
<style>
  table {
    border-collapse: collapse;
  }

  td {
    border: 1px solid black;
    width: 40px;
    height: 40px;
    text-align: center;
  }
</style>
</head>

<body>
    <!-- 아래는 테이블의 기본적인 html구조이자 여기서 사용되는 테이블의 구조이다. -->
  <!-- <table>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </table> -->
<script>
  const { body } = document; //식별자에다가 중괄호를 씌우는 방식은 처음이다.
  /*
  위 코드설명: 구조분해 할당이라는 이름으로 비교적 최신문법으로 요즘 많이 사용된다. 객체 내부의 속성과
  할당하는 변수명이 같을때 이렇게 코드를 고쳐 쓸 수 있다. 원래 코드는 아래와 같다. 
  const body=document.body;
  */
/*
구조분해 할당은 다음과 같은 다량의코드를 응축시키는데 그 효과가 크다. 예를들어 다음의 코드를 
const body=document.body;
const createElement=document.createElement;
//아래와 같이 바꿀수 있음
const {body, createElement}=document;
*/

  const $table = document.createElement('table');
  const $result = document.createElement('div');
  const rows = [];
  let turn = 'O';

  // [
  //   [td, td, td],
  //   [td, td, td],
  //   [td, td, td],
  // ]

  const checkWinner = (target) => {
    const rowIndex = target.parentNode.rowIndex;//target은 $table임. parentNode라면 뭐지? target.rowIndex면 바로 이해가 될텐데.... 
    const cellIndex = target.cellIndex;

    // 세 칸 다 채워졌나?
    let hasWinner = false;
    // 가로줄 검사
    if (
      rows[rowIndex][0].textContent === turn &&
      rows[rowIndex][1].textContent === turn &&
      rows[rowIndex][2].textContent === turn
    ) {
      hasWinner = true;
    }
    // 세로줄 검사
    if (
      rows[0][cellIndex].textContent === turn &&
      rows[1][cellIndex].textContent === turn &&
      rows[2][cellIndex].textContent === turn
    ) {
      hasWinner = true;
    }
    // 대각선 검사
    if (
      rows[0][0].textContent === turn &&
      rows[1][1].textContent === turn &&
      rows[2][2].textContent === turn
    ) {
      hasWinner = true;
    }
    if (
      rows[0][2].textContent === turn &&
      rows[1][1].textContent === turn &&
      rows[2][0].textContent === turn
    ) {
      hasWinner = true;
    }
    return hasWinner;
  };

  const checkWinnerAndDraw = (target) => {//승자가 있는지 확인하고 있다면 프로그램 중지하고 승부가 결정나지 않으면 턴을 바꿈. 
    const hasWinner = checkWinner(target);
    // 승자가 있으면
    if (hasWinner) {
      $result.textContent = `${turn}님이 승리!`;
      $table.removeEventListener('click', callback);
      return;
    }
    // 승자가 없으면
    const draw = rows.flat().every((cell) => cell.textContent);//아무 문자열이 없는 빈 칸이 있는지를 검사함. 하나라도 빈칸이 있으면 false임
    if (draw) {
      $result.textContent = `무승부`;
      return;
    }
    turn = turn === 'X' ? 'O' : 'X';
  };

  let clickable = true;
  const callback = (event) => {
    if (!clickable) {
      return;
    }
    if (event.target.textContent !== '') { // 칸이 이미 채워져 있는지 
      console.log('빈칸이 아닙니다.');
      return;
    }
    // 빈칸이면
    console.log('빈칸입니다');
    event.target.textContent = turn;//turn은 변수이다. 즉, event.target.textContent의 내용으로 문자열이 아닌 변수도 올수 있다. 아 근데 이건 당연하다 turn이 문자열변수이므로.  
    // 승부 판단하기
    checkWinnerAndDraw(event.target);
    if (turn === 'X') {
      const emptyCells = rows.flat().filter((v) => !v.textContent);//위의 every메서드와 같이 filter도 그 안에 결과로 true 또는 false가 오는 식이 
      //오고 true일 경우만 그 요소를 최종적으로 반환되는 배열에 포함시킨다. 여기서는 textContent가 비어 있는 것만을 얻고자하는 것이므로 비어있을때 그 결과가 false오는
      //것을 이용하여 !를 붙여 비어있는 요소만을 반환하고 있음. 최종적으로 emptyCells에는 $td들로 이루어진 배열이 됨. 

      const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      clickable = false;
      setTimeout(() => {
        randomCell.textContent = 'X';
        checkWinnerAndDraw(randomCell);
        clickable = true;
      }, 1000);
    }
  };

  for (let i = 1; i <= 3; i++) {
    const $tr = document.createElement('tr');
    const cells = [];
    for (let j = 1; j <= 3; j++) {
      const $td = document.createElement('td');
      cells.push($td);//JS의 2차원 데이터 배열을 만드는중
      $tr.append($td);//GUI의 2차원 배열 만드는 중
    }
    rows.push(cells);//JS의 2차원데이터 배열을 만드는중
    $table.append($tr);//GUI의 2차원 배열 만드는 중
  }
  $table.addEventListener('click', callback);
  body.append($table);
  body.append($result);
</script>
</body>
</html>